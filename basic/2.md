### Float浮点型
- float又叫double、real；
- -要测试浮点数是否相等，要使用一个仅比该数值大一丁点的最小误差值。该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值。
- NAN表示一个在浮点运算中不可表述的值，不能做比较（包括自身比较），应该用is_nan()检查；

### string
- 有一系列字符组成，每个字符是一个字节，也就意味着只能支持256的字符集，不支持Unicode；
- string最大2GB；

string有四种表达方式：
1. 单引号
2. 双引号
3. heredoc（<<<双引号结构,这里的双引号可省略）
4. nowdoc（<<<单引号结构）

- 带双引号定义的字符串最重要的特征是变量会被解析；
- doc类型定义的字符串结束时所引用的标识符必须在该行的第一列；
- 不象 heredoc 结构，nowdoc 结构可以用在任意的静态数据环境中，最典型的示例是用来初始化类的属性或常量；
- 字符串中变量解析的复杂规则不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式；
- string 中的字符可以通过一个从 0 开始的下标，用类似 array 结构中的方括号包含对应的数字来访问和修改；
- string 也可用花括号访问，比如 $str{42}；
- 用超出字符串长度的下标写入将会拉长该字符串并以空格填充；
- 非整数类型下标会被转换成整数。非法下标类型会产生一个 E_NOTICE 级别错误；
- 用负数下标写入字符串时会产生一个 E_NOTICE 级别错误，用负数下标读取字符串时返回空字符串；
- 写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符；
- PHP 的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。仅应对单字节编码例如 ISO-8859-1 的字符串进行此类操作；
- PHP 5.4 起字符串下标必须为整数或可转换为整数的字符串，否则会发出警告。之前例如 "foo" 的下标会无声地转换成 0；
- 用 [] 或 {} 访问任何其它类型（不包括数组或具有相应接口的对象实现）的变量只会无声地返回 NULL；
- 一个布尔值 boolean 的 TRUE 被转换成 string 的 "1"。Boolean 的 FALSE 被转换成 ""（空字符串）。这种转换可以在 boolean 和 string 之间相互进行；
- 数组 array 总是转换成字符串 "Array"；
- 在 PHP 4 中对象 object 总是被转换成字符串 "Object"，如果为了调试原因需要打印出对象的值，请继续阅读下文。为了得到对象的类的名称，可以用 get_class() 函数。自 PHP 5 起，适当时可以用 __toString 方法；
- 资源 resource 总会被转变成 "Resource id #1" 这种结构的字符串，其中的 1 是 PHP 在运行时分配给该 resource 的唯一值。不要依赖此结构，可能会有变更。要得到一个 resource 的类型，可以用函数 get_resource_type()；
- NULL 总是被转变成空字符串；
- 大部分的 PHP 值可以转变成 string 来永久保存，这被称作串行化，可以用函数 serialize() 来实现。如果 PHP 引擎设定支持 WDDX，PHP 值也可被串行化为格式良好的 XML 文本；
- 不要想像在 C 语言中的那样，通过将一个字符转换成整数以得到其代码。使用函数 ord() 和 chr() 实现 ASCII 码和字符间的转换；

### Array
PHP中的数组实际上是一个有序映射。
- 5.4 起可以使用短数组定义语法，用 [] 替代 array()；

key 会有如下的强制转换：
- 包含有合法整型值的字符串会被转换为整型。例如键名 "8" 实际会被储存为 8。但是 "08" 则不会强制转换，因为其不是一个合法的十进制数值。
- 浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。
- 布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。
- Null 会被转换为空字符串，即键名 null 实际会被储存为 ""。
- 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。