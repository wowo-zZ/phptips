### 类与对象
自 PHP 5 起完全重写了对象模型以得到更佳性能和更多特性。这是自 PHP 4 以来的最大变化。PHP 5 具有完整的对象模型；
- 创建对象有三种方式：new class, new object, class::getNew();
- 当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数;
- 自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。这对使用了 命名空间 的类尤其有用;
- 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）；

### 属性
- 属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值；

### 类常量
- 可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号

### 类的自动加载
- `spl_autoload_register()` 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类；
- 尽管 `__autoload()` 函数也能自动加载类和接口，但更建议使用 `spl_autoload_register()` 函数。 `spl_autoload_register()` 提供了一种更加灵活的方式来实现类的自动加载（同一个应用中，可以支持任意数量的加载器，比如第三方库中的）。因此，不再建议使用 `__autoload()` 函数，在以后的版本中它可能被弃用；

### 构造函数和析构函数
- 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()；
- 与其它方法不同，当 `__construct()` 被与父类 `__construct()` 具有不同参数的方法覆盖时，PHP 不会产生一个 E_STRICT 错误信息；
- 和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的；
- 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误；

### 访问控制
- 同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。

### 对象继承
- 除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口；

### 范围解析操作符 （::）
- self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的