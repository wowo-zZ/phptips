### 重载
php的重载不是严格意义上的重载。它是指动态的创建类属性和方法，这一点是通过魔术方法来实现的。
- 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。本节后面将使用不可访问属性和不可访问方法来称呼这些未定义或不可见的类属性或方法；
- 属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被 声明为 static。从 PHP 5.3.0 起, 将这些魔术方法定义为 static 会产生一个警告；
- 在除 isset() 外的其它语言结构中无法使用重载的属性，这意味着当对一个重载的属性使用 empty() 时，重载魔术方法将不会被调用。为避开此限制，必须将重载属性赋值到本地变量再使用 empty()；
- 在对象中调用一个不可访问方法时，`__call()`会被调用。在静态上下文中调用一个不可访问方法时，`__callStatic()`会被调用;

### 魔术方法
- `__sleep()` && `__wakeup()`:序列化/反序列化时做预备工作只用；
- `__toString()`;
- `__invode()`:当尝试以函数调用的方式调用一个对象时，会调用该对象的`__invoke`方法；
- `__set_state()`:编排var_export时的输出格式；
- `__debugInfo()`:编排var_dump时的输出格式；

### Final
- PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承;
- 属性不能被定义为 final，只有类和方法才能被定义为 final;



### 对象复制

- 魔术方法`__clone`用来辅助对象的克隆；
- 使用`clone`结构复制对象，实际上是完成对原对象属性的浅复制，复制成功之后，会调用新对象的`__clone`方法，可以在这个方法里面做一些后处理，达到引用属性的深复制



### 对象比较 

- c

- 比较符`==`会比较两个变量所引用的对象的类型(即类名)、属性、属性值，如果相同，则认为相等；
- 比较符`===`会比较两个变量是否引用同一个对象，如果是，则认为相等；



### 类型约束

- 类型约束只能针对object、interface、array、callable，无法进行标量(int、string、Traits)约束；
- 如果为类型约束添加了默认值NULL，那么可以传入NULL，这是唯一一种情况；
- 类型约束具有子类继承性；



### 后期静态绑定

- 指的是在程序运行时，静态方法的主调方绑定到运行时的类（通常是子类），而不是该静态方法定义的类(通常是父类)；
- 使用static关键字，代表绑定的类，常用的方法是`static::func_name()`；



### 对象引用

对象的引用、传递、返回(函数回参)使用的都是标识符作为引用。



### 序列化

- 序列化/反序列化之前，类必须有定义；
- 序列化只保存类名、属性名、属性值，并不会保存方法；